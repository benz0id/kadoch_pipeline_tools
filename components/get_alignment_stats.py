from pathlib import Path
from typing import List


def get_alignment_stats(stats_filepaths: List[Path], out_filepath: Path,
                        sort: bool = True) -> Path:
    """
    Given a list of alignment stats result files, as generated by bowtie
    alignment, compiles them into a single csv file at the given destination.
    :param sort: Whether to sort the stats by their sample number.
    :param stats_filepaths: List of paths to valid bowtie alignment result
    files.
    :param out_filepath: The path to the resultant tsv file.
    :return: The path to the resultant tsv file.
    """
    dne = []
    for filepath in stats_filepaths:
        if not filepath.exists():
            dne.append(filepath)
    if dne:
        s = ''
        for missing_file in dne:
            s += '\n\t' + str(missing_file)

        raise ValueError('The following file(s) could not be found:' + s)

    if not out_filepath.parent.exists():
        raise ValueError(f"The supplied output directory: {out_filepath} "
                         f"does not exist.")

    with open(stats_filepaths[0], 'r') as sample_stats_file:
        header = sample_stats_file.readline()

    first_col = header.split('\t')[0].strip()
    assert first_col == 'ID' or first_col == 'Sample':

    stats = []
    for stats_filepath in stats_filepaths:
        with open(stats_filepath, 'r') as stats_file:
            data = stats_file.readlines()[1]
            sample_id = header.split('\t')[0].strip()
            stats.append((sample_id, data))

    if sort:
        stats = sorted(stats)

    stats = [sample_stat[1] for sample_stat in stats]

    with open(out_filepath, 'w') as outfile:
        outfile.write(header + '\n')
        for stat in stats:
            outfile.write(stat)

    return out_filepath


def get_sample_names(sample_prefix: str, start: int, stop: int) -> List[str]:
    """
    Generate a list of sample IDs in the given range.
    :param sample_prefix: The sample prefix.
    :param start: The first sample number (inclusive)
    :param stop: The last sample number (inclusive)
    :return: A list of sample IDs
    """
    return [sample_prefix + str(i) for i in range(start, stop + 1)]
